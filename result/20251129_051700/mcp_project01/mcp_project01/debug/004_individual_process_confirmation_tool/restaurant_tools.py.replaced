#!/usr/bin/env python3
"""
Restaurant Tools Functions for MCP Workflow
Each function here is designed to be registered as an MCP tool
"""

import json
import re
import os
import asyncio
import logging
from typing import Dict, Any, List, Optional
from datetime import datetime
from .utils.logging_decorator import log_mcp_call, setup_logging

# Configure logging
logger = setup_logging("logs/restaurant_tools.log")


class AIHelper:
    """AI helper class with fallback to rule-based processing"""

    @staticmethod
    async def classify_intent_with_ai(
        message: str, current_state: str
    ) -> Dict[str, Any]:
        """Classify intent using OpenAI or fallback to rules"""
        try:
            # Try OpenAI first if available
            if os.getenv("OPENAI_API_KEY"):
                import openai

                openai.api_key = os.getenv("OPENAI_API_KEY")

                response = await openai.ChatCompletion.acreate(
                    model="gpt-4o-mini",
                    messages=[
                        {
                            "role": "system",
                            "content": "Classify the user's intent as one of: greeting, ordering, confirmation, clarification. Return only the intent word.",
                        },
                        {"role": "user", "content": message},
                    ],
                    max_tokens=20,
                    temperature=0.3,
                )

                intent = response.choices[0].message.content.strip().lower()
                confidence = 0.9

                if intent in ["greeting", "ordering", "confirmation", "clarification"]:
                    return {"intent": intent, "confidence": confidence}

        except Exception as e:
            logger.warning(f"OpenAI classification failed: {e}")

        # Fallback to rule-based classification
        return AIHelper._classify_intent_rules(message, current_state)

    @staticmethod
    def _classify_intent_rules(message: str, current_state: str) -> Dict[str, Any]:
        """Rule-based intent classification"""
        message_lower = message.lower().strip()

        # Greeting patterns
        greeting_patterns = [
            r"\b(hello|hi|hey|good\s+(morning|afternoon|evening))\b",
            r"^(what\'s up|howdy|greetings)",
            r"^\w{1,10}$",  # Single word greetings
        ]

        # Confirmation patterns
        confirmation_patterns = [
            r"\b(yes|yeah|yep|correct|right|confirm|ok|okay)\b",
            r"\b(that\'s right|sounds good|perfect)\b",
        ]

        # Order patterns (menu items)
        order_patterns = [
            r"\b(latte|coffee|tea|cappuccino|chocolate|pepsi|espresso|americano|mocha|frappuccino)\b",
            r"\b\d+\s*(x\s*)?[a-z]",  # quantities
            r"\btable\s*\d+\b",
            r"\b(i want|i would like|order|get me)\b",  # order intent words
        ]

        # Check patterns
        for pattern in greeting_patterns:
            if re.search(pattern, message_lower):
                return {"intent": "greeting", "confidence": 0.8}

        # If currently waiting for confirmation
        if current_state == "confirmation":
            for pattern in confirmation_patterns:
                if re.search(pattern, message_lower):
                    return {"intent": "confirmation", "confidence": 0.85}

        # Check for ordering intent
        order_matches = sum(
            1 for pattern in order_patterns if re.search(pattern, message_lower)
        )
        if order_matches >= 1:
            return {"intent": "ordering", "confidence": 0.7 + (order_matches * 0.1)}

        # Default to clarification if unclear
        return {"intent": "clarification", "confidence": 0.6}

    @staticmethod
    async def generate_response_with_ai(
        response_type: str, context: Dict[str, Any]
    ) -> str:
        """Generate response using OpenAI or fallback to templates"""
        try:
            if os.getenv("OPENAI_API_KEY"):
                import openai

                openai.api_key = os.getenv("OPENAI_API_KEY")

                # Build context for AI
                system_message = f"You are a friendly restaurant chatbot. Generate a {response_type} response."
                user_context = f"Context: {context}"

                response = await openai.ChatCompletion.acreate(
                    model="gpt-4o-mini",
                    messages=[
                        {"role": "system", "content": system_message},
                        {"role": "user", "content": user_context},
                    ],
                    max_tokens=150,
                    temperature=0.3,
                )

                return response.choices[0].message.content.strip()

        except Exception as e:
            logger.warning(f"OpenAI response generation failed: {e}")

        # Fallback to templates
        return AIHelper._generate_template_response(response_type, context)

    @staticmethod
    def _generate_template_response(response_type: str, context: Dict[str, Any]) -> str:
        """Generate response using templates"""
        templates = {
            "greeting": "Hello! Welcome to our restaurant. How can I assist you today? What would you like to order?",
            "clarification": "I'm sorry, I couldn't understand your order clearly. Could you please tell me what items you'd like and your table number?",
            "error": "I noticed some issues with your order. Please try again or contact our staff for assistance.",
            "missing_info": "I have your order, but I need some additional information. Could you provide that?",
            "order_summary": "Here's your order summary. Please confirm if this is correct.",
            "success": "Thank you for confirming! Your order has been received and logged. It will be prepared shortly. Enjoy your time with us!",
        }

        return templates.get(response_type, "How can I help you today?")


class GoogleSheetsHelper:
    """Google Sheets integration helper"""

    @staticmethod
    async def log_order_to_sheets(order_data: Dict[str, Any]) -> Dict[str, Any]:
        """Log order to Google Sheets"""
        try:
            # Check if Google credentials are available
            credentials_path = os.getenv("GOOGLE_APPLICATION_CREDENTIALS")
            sheets_id = os.getenv("GOOGLE_SHEETS_ID")

            if not credentials_path or not sheets_id:
                logger.warning(
                    "Google Sheets credentials not configured, using mock mode"
                )
                return {
                    "success": True,
                    "records_added": len(order_data.get("items", [])),
                    "mock_mode": True,
                    "message": "Order logged (mock mode)",
                }

            # Try real Google Sheets integration
            if os.path.exists(credentials_path):
                from google.oauth2.service_account import Credentials
                from googleapiclient.discovery import build

                # Setup credentials
                credentials = Credentials.from_service_account_file(
                    credentials_path,
                    scopes=["https://www.googleapis.com/auth/spreadsheets"],
                )

                service = build("sheets", "v4", credentials=credentials)

                # Prepare data for sheets
                rows = []
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

                for item in order_data.get("items", []):
                    rows.append(
                        [
                            item.get("name", "Unknown"),
                            item.get("quantity", 1),
                            order_data.get("table_number", "N/A"),
                            timestamp,
                        ]
                    )

                # Write to sheets
                body = {"values": rows}
                result = (
                    service.spreadsheets()
                    .values()
                    .append(
                        spreadsheetId=sheets_id,
                        range="Sheet1!A:D",
                        valueInputOption="RAW",
                        body=body,
                    )
                    .execute()
                )

                return {
                    "success": True,
                    "records_added": len(rows),
                    "updated_cells": result.get("updates", {}).get("updatedCells", 0),
                    "message": f"Successfully logged {len(rows)} items to Google Sheets",
                }

        except Exception as e:
            logger.error(f"Google Sheets logging failed: {e}")
            return {
                "success": False,
                "error": str(e),
                "message": "Failed to log to Google Sheets",
            }

        # Fallback to mock mode
        return {
            "success": True,
            "records_added": len(order_data.get("items", [])),
            "mock_mode": True,
            "message": "Order logged (mock mode - Google Sheets not configured)",
        }


# MCP Tool Functions
async def initialize_conversation(
    step: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """Initialize or retrieve conversation context"""
    try:
        conversation_id = context.get("conversation_id", "default")
        user_message = context.get("user_input", "")

        # Initialize conversation state if needed
        if "conversation_state" not in context:
            context["conversation_state"] = "greeting"

        logger.info(f"Initialized conversation {conversation_id}")

        return {
            "success": True,
            "conversation_id": conversation_id,
            "user_message": user_message,
            "initial_state": context.get("conversation_state"),
            "message": "Conversation initialized successfully",
        }

    except Exception as e:
        logger.error(f"Conversation initialization failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "message": "Failed to initialize conversation",
        }


async def classify_intent(
    step: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """Classify user intent from message using AI or rules"""
    try:
        user_message = context.get("user_input", "")
        current_state = context.get("conversation_state", "greeting")

        if not user_message:
            return {
                "success": False,
                "error": "No user message provided",
                "intent": "clarification",
                "confidence": 0.0,
            }

        # Use AI helper for classification
        result = await AIHelper.classify_intent_with_ai(user_message, current_state)

        logger.info(
            f"Classified intent: {result['intent']} (confidence: {result['confidence']})"
        )

        return {
            "success": True,
            "intent": result["intent"],
            "confidence": result["confidence"],
            "message": f"Intent classified as {result['intent']}",
        }

    except Exception as e:
        logger.error(f"Intent classification failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "intent": "clarification",
            "confidence": 0.0,
        }


async def extract_order_info(
    step: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """Extract order information from user input"""
    try:
        user_message = context.get("user_input", "")

        if not user_message:
            return {
                "success": False,
                "error": "No user message to extract from",
                "items": [],
                "quantities": [],
                "table_number": None,
            }

        message_lower = user_message.lower()

        # Extract menu items (English only)
        menu_items = [
            "latte",
            "coffee",
            "tea",
            "cappuccino",
            "chocolate",
            "pepsi",
            "espresso",
            "americano",
            "mocha",
            "frappuccino",
        ]

        found_items = []
        quantities = []

        # Look for quantity + item patterns
        for item in menu_items:
            # Pattern: "2 lattes" or "2x latte" or just "latte"
            patterns = [
                rf"(\d+)\s*{item}s?",  # "2 lattes"
                rf"(\d+)\s*(?:x\s*)?{item}s?",  # "2x latte"
                rf"{item}s?(?:\s*x\s*(\d+))?",  # "latte x 2"
                rf"\b{item}\b",  # just "latte"
            ]

            item_found = False
            for pattern in patterns:
                matches = re.findall(pattern, message_lower)
                if matches:
                    # Extract quantity
                    for match in matches:
                        if isinstance(match, tuple):
                            # Find the first digit in the tuple
                            qty = 1
                            for part in match:
                                if part and part.isdigit():
                                    qty = int(part)
                                    break
                        elif isinstance(match, str) and match.isdigit():
                            qty = int(match)
                        else:
                            qty = 1

                        found_items.append(item)
                        quantities.append(qty)
                        item_found = True

                    if item_found:
                        break  # Found this item, move to next

        # Extract table number (English only)
        table_patterns = [
            r"table\s*(?:number\s*|no\.?\s*|#\s*)?(\d+)",
            r"table\s*(\d+)",
            r"(?:for\s*)?table\s*(\d+)",
        ]

        table_number = None
        for pattern in table_patterns:
            match = re.search(pattern, message_lower)
            if match:
                table_number = int(match.group(1))
                break

        logger.info(f"Extracted: {len(found_items)} items, table: {table_number}")

        # Create extraction result structure
        extraction_result = {
            "items": found_items,
            "quantities": quantities,
            "table_number": table_number,
            "extraction_count": len(found_items),
        }

        return {
            "success": True,
            "extraction_result": extraction_result,
            "items": found_items,
            "quantities": quantities,
            "table_number": table_number,
            "extraction_count": len(found_items),
            "message": f"Extracted {len(found_items)} items"
            + (f" for table {table_number}" if table_number else ""),
        }

    except Exception as e:
        logger.error(f"Order extraction failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "items": [],
            "quantities": [],
            "table_number": None,
        }


async def validate_extraction(
    step: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """Validate extraction results"""
    try:
        # Get extraction results from previous step
        step_data = context.get("step_data", {})
        extraction_result = step_data.get("step_4", {})

        if not extraction_result:
            return {
                "success": False,
                "error": "No extraction result found",
                "valid_extraction": False,
                "confidence": 0.0,
                "extraction_errors": ["No extraction data available"],
            }

        items = extraction_result.get("items", [])
        quantities = extraction_result.get("quantities", [])
        table_number = extraction_result.get("table_number")

        errors = []
        confidence = 0.5  # Base confidence

        # Validate items and quantities match
        if len(items) != len(quantities):
            errors.append("Mismatch between items and quantities")
            confidence -= 0.2

        # Check if we have any items
        if not items:
            errors.append("No menu items found")
            confidence -= 0.3
        else:
            confidence += 0.2 * len(items)  # More items = higher confidence

        # Check table number
        if not table_number:
            # This is not an error, just missing info
            pass
        else:
            confidence += 0.2

        # Set minimum confidence
        confidence = max(0.0, min(1.0, confidence))

        valid_extraction = len(errors) == 0 and len(items) > 0

        logger.info(
            f"Validation: {valid_extraction}, confidence: {confidence}, errors: {len(errors)}"
        )

        return {
            "success": True,
            "valid_extraction": valid_extraction,
            "confidence": confidence,
            "extraction_errors": errors,
            "confidence_threshold": 0.3,
            "message": f"Validation complete: {'valid' if valid_extraction else 'invalid'}",
        }

    except Exception as e:
        logger.error(f"Extraction validation failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "valid_extraction": False,
            "confidence": 0.0,
            "extraction_errors": ["Validation process failed"],
        }


async def validate_format_order(
    step: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """Create and validate order object"""
    try:
        # Get extraction results
        step_data = context.get("step_data", {})
        extraction_result = step_data.get("step_4", {})

        items = extraction_result.get("items", [])
        quantities = extraction_result.get("quantities", [])
        table_number = extraction_result.get("table_number")

        # Create order items
        order_items = []
        for i, item in enumerate(items):
            qty = quantities[i] if i < len(quantities) else 1
            order_items.append({"name": item, "quantity": qty})

        # Check what's missing
        missing_info = []
        if not order_items:
            missing_info.append("items")
        if not table_number:
            missing_info.append("table_number")

        is_complete = len(missing_info) == 0

        # Create order object
        order = {
            "items": order_items,
            "table_number": table_number,
            "status": "draft",
            "timestamp": datetime.now().isoformat(),
        }

        # Update context with order data
        context["order_data"] = order

        logger.info(
            f"Order formatted: {len(order_items)} items, complete: {is_complete}"
        )

        return {
            "success": True,
            "order": order,
            "is_complete": is_complete,
            "missing_info": missing_info,
            "total_items": len(order_items),
            "message": f"Order formatted with {len(order_items)} items",
        }

    except Exception as e:
        logger.error(f"Order formatting failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "order": None,
            "is_complete": False,
            "missing_info": ["processing_error"],
        }


async def generate_greeting_response(
    step: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """Generate greeting response using AI or template"""
    try:
        response = await AIHelper.generate_response_with_ai("greeting", context)

        return {
            "success": True,
            "response": response,
            "new_state": "ordering",
            "message": "Greeting response generated",
        }

    except Exception as e:
        logger.error(f"Greeting response generation failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "response": "Hello! How can I help you today?",
            "new_state": "ordering",
        }


async def generate_clarification_response(
    step: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """Generate clarification response using AI or template"""
    try:
        response = await AIHelper.generate_response_with_ai("clarification", context)

        return {
            "success": True,
            "response": response,
            "new_state": "ordering",
            "message": "Clarification response generated",
        }

    except Exception as e:
        logger.error(f"Clarification response generation failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "response": "I'm sorry, I couldn't understand your order clearly. Could you please tell me what items you'd like and your table number?",
            "new_state": "ordering",
        }


async def generate_error_response(
    step: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """Generate error response using AI or template"""
    try:
        # Get errors from step data
        step_data = context.get("step_data", {})
        validation_result = step_data.get("step_5", {})
        errors = validation_result.get("extraction_errors", [])

        error_text = "; ".join(errors) if errors else "Unknown error occurred"
        context["error_details"] = error_text

        response = await AIHelper.generate_response_with_ai("error", context)

        return {
            "success": True,
            "response": f"I noticed some issues with your order: {error_text}. Please try again.",
            "new_state": "ordering",
            "message": "Error response generated",
        }

    except Exception as e:
        logger.error(f"Error response generation failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "response": "I encountered an error processing your request. Please try again or contact our staff.",
            "new_state": "ordering",
        }


async def generate_missing_info_response(
    step: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """Generate response for missing information using AI or template"""
    try:
        # Get order and missing info
        step_data = context.get("step_data", {})
        order_result = step_data.get("step_6", {})

        order = order_result.get("order", {})
        missing_info = order_result.get("missing_info", [])

        if not order or not missing_info:
            return {
                "success": False,
                "error": "No order or missing info data",
                "response": "Please provide your order details.",
                "new_state": "ordering",
            }

        # Build response
        items_text = ", ".join(
            [f"{item['quantity']} {item['name']}" for item in order.get("items", [])]
        )
        missing_text = " and ".join(missing_info).replace("_", " ")

        response = f"I have your order for {items_text}, but I need the {missing_text}. Could you provide that information?"

        return {
            "success": True,
            "response": response,
            "new_state": "clarification",
            "message": "Missing info response generated",
        }

    except Exception as e:
        logger.error(f"Missing info response generation failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "response": "I need some additional information about your order. Could you provide more details?",
            "new_state": "clarification",
        }


async def generate_order_summary(
    step: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """Generate order summary using AI or template"""
    try:
        # Get order data
        step_data = context.get("step_data", {})
        order_result = step_data.get("step_6", {})
        order = order_result.get("order", {})

        if not order or not order.get("items"):
            return {
                "success": False,
                "error": "No order data found",
                "response": "No order to summarize.",
                "new_state": "ordering",
            }

        # Build summary
        items_text = "\n".join(
            [f"{item['quantity']} {item['name']}" for item in order["items"]]
        )
        table_text = f"Table number: {order.get('table_number', 'Not specified')}"

        response = f"Here's your order summary:\n{items_text}\n{table_text}\n\nShall I confirm this order?"

        return {
            "success": True,
            "response": response,
            "new_state": "confirmation",
            "message": "Order summary generated",
        }

    except Exception as e:
        logger.error(f"Order summary generation failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "response": "Unable to generate order summary. Please try again.",
            "new_state": "ordering",
        }



async def process_confirmation(step: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
    user_input = context.get("conversation_context", {}).get("user_input", "").strip().lower()
    order_data = context.get("order_data")
    
    if user_input in ["yes", "confirm"]:
        confirmation_status = "confirmed"
        response_message = "Your order has been confirmed."
    elif user_input in ["no", "cancel"]:
        confirmation_status = "canceled"
        response_message = "Your order has been canceled."
    else:
        confirmation_status = "pending"
        response_message = "Please respond with 'yes' to confirm or 'no' to cancel your order."
    
    return {
        "confirmation_status": confirmation_status,
        "response_message": response_message,
        "order_data": order_data,
        "step_data": context.get("step_data", {})
    }



async def log_order_to_sheets(
    step: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """Log order to Google Sheets"""
    try:
        # Get confirmed order
        step_data = context.get("step_data", {})
        confirmation_result = step_data.get("step_8", {})
        order_data = confirmation_result.get("confirmed_order")

        if not order_data:
            return {
                "success": False,
                "error": "No confirmed order to log",
                "records_added": 0,
            }

        # Use Google Sheets helper
        result = await GoogleSheetsHelper.log_order_to_sheets(order_data)

        return result

    except Exception as e:
        logger.error(f"Google Sheets logging failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "records_added": 0,
            "message": "Failed to log order to Google Sheets",
        }


async def generate_success_response(
    step: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """Generate success confirmation response"""
    try:
        response = await AIHelper.generate_response_with_ai("success", context)

        return {
            "success": True,
            "response": response,
            "new_state": "completed",
            "message": "Success response generated",
        }

    except Exception as e:
        logger.error(f"Success response generation failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "response": "Thank you for confirming! Your order has been received and logged. It will be prepared shortly. Enjoy your time with us!",
            "new_state": "completed",
        }


async def update_conversation_state(
    step: Dict[str, Any], context: Dict[str, Any]
) -> Dict[str, Any]:
    """Update conversation state"""
    try:
        # Get the most recent response and state from step data
        step_data = context.get("step_data", {})

        final_response = "Hello! How can I assist you today?"
        new_state = context.get("conversation_state", "greeting")

        # Find the most recent response
        for step_id in sorted(step_data.keys(), reverse=True):
            step_result = step_data[step_id]
            if isinstance(step_result, dict):
                if "response" in step_result:
                    final_response = step_result["response"]
                if "new_state" in step_result and step_result["new_state"]:
                    new_state = step_result["new_state"]
                break

        # Update context
        context["conversation_state"] = new_state

        return {
            "success": True,
            "conversation_state": new_state,
            "final_response": final_response,
            "message": f"Conversation state updated to {new_state}",
        }

    except Exception as e:
        logger.error(f"State update failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "conversation_state": "error",
            "final_response": "I'm sorry, I encountered an error. Please try again.",
        }
